import json
from dgl.distributed import graph_services, load_partition_book
import dgl.backend as F
import time
import argparse
import os
import torch
from dgl.data.utils import load_graphs

etypes_key = 'etypes'
edge_map_key = 'edge_map'
canonical_etypes_delimiter = ':'

def etype2canonical_etype(part_config):
    gpb, _, _, etypes =  load_partition_book(part_config=part_config, part_id=0)
    eid = []
    etype_id = []
    for etype in etypes:
        type_eid = F.zeros((1,), F.int64, F.cpu())
        eid.append(gpb.map_to_homo_eid(type_eid, etype))
        etype_id.append(etypes[etype])
    eid = F.cat(eid, 0)
    etype_id = torch.IntTensor(etype_id)
    partition_id = gpb.eid2partid(eid)
    canonical_etypes = {}
    part_ids = [part_id for part_id in range(gpb.num_partitions()) if part_id in partition_id]
    for part_id in part_ids:
        seed_edges = F.boolean_mask(eid, partition_id == part_id)
        seed_edge_tids = F.boolean_mask(etype_id, partition_id == part_id)
        c_etype = _find_c_etypes_in_partition(seed_edges, seed_edge_tids, part_id, part_config)
        canonical_etypes.update(c_etype)
    return canonical_etypes

def _find_c_etypes_in_partition(seed_edges, seed_edge_tids, part_id, part_config):
    folder, _ = os.path.split(part_config)
    local_g = load_graphs(f'{folder}/part{part_id}/graph.dgl')[0][0]
    partition_book = load_partition_book(part_config=part_config, part_id=part_id)[0]
    ntypes, etypes = partition_book.ntypes, partition_book.etypes
    src, dst = graph_services._find_edges(local_g, partition_book, seed_edges)
    src_tids, _ = partition_book.map_to_per_ntype(src)
    dst_tids, _ = partition_book.map_to_per_ntype(dst)
    canonical_etypes = {}
    for src_tid, etype_id, dst_tid in zip(src_tids, seed_edge_tids, dst_tids):
        src_tid = F.as_scalar(src_tid)
        etype_id = F.as_scalar(etype_id)
        dst_tid = F.as_scalar(dst_tid)
        c_etype = (ntypes[src_tid], etypes[etype_id], ntypes[dst_tid])
        canonical_etypes[canonical_etypes_delimiter.join(c_etype)] = etype_id
    return canonical_etypes

def check_if_old_version(config):
    first_etype = list(config[etypes_key].keys())[0]
    etype_tuple = first_etype.split(canonical_etypes_delimiter)
    return len(etype_tuple) == 1

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Convert etypes in partition json config file, which are \
        generated by old version partition code, to canonical etypes.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--part-config', type=str, help='The file of the partition config')

    args, _ = parser.parse_known_args()
    
    assert os.path.isfile(args.part_config), \
            'A user has to specify a partition configuration file with --part_config.'
    
    start = time.time()

    with open(args.part_config, 'r+', encoding='utf-8') as f:
        config = json.load(f)
        if check_if_old_version(config):
            canonical_etypes = etype2canonical_etype(args.part_config)

            # convert edge_map key from etype -> c_etype
            new_edge_map = {}
            for e_type, range in config[edge_map_key].items():
                eid = config[etypes_key][e_type]
                c_etype = [key for key in canonical_etypes if canonical_etypes[key] == eid][0]
                new_edge_map[c_etype] = range
            config[edge_map_key] = new_edge_map
            
            config[etypes_key] = canonical_etypes
            f.seek(0)
            json.dump(config, f, indent=4)
            f.truncate()

    end = time.time()
    print(f'elplased time in seconds: {end - start}')
