"""Synthetic datasets for developing GNN explainability approaches."""
import math
import networkx as nx
import numpy as np
import os
import random

from .dgl_dataset import DGLBuiltinDataset
from .utils import save_graphs, load_graphs
from .. import backend as F
from .. import batch
from ..convert import graph
from ..transforms import reorder_graph

class BAShapes(DGLBuiltinDataset):
    r"""BA-SHAPES dataset from `GNNExplainer: Generating Explanations for Graph Neural Networks
    <https://arxiv.org/abs/1903.03894>`__

    This is a synthetic dataset for node classification. It is generated by performing the
    following steps in order.

    - Construct a base Barabási–Albert (BA) graph.
    - Construct a set of five-node house-structured network motifs.
    - Attach the motifs to randomly selected nodes of the base graph.
    - Perturb the graph by adding random edges.
    - Nodes are assigned to 4 classes. Nodes of label 0 belong to the base BA graph. Nodes of
      label 1, 2, 3 are separately at the middle, bottom, or top of houses.
    - Generate constant feature for all nodes, which is 1.

    Parameters
    ----------
    num_base_nodes : int, optional
        Number of nodes in the base BA graph. Default: 300
    num_base_edges_per_node : int, optional
        Number of edges to attach from a new node to existing nodes in constructing the base BA
        graph. Default: 5
    num_motifs : int, optional
        Number of house-structured network motifs to use. Default: 80
    perturb_ratio : float, optional
        Number of random edges to add in perturbation divided by the number of edges in the
        original graph. Default: 0.01
    seed : integer, random_state, or None
        Indicator of random number generation state. Default: None
    raw_dir : str, optional
        Raw file directory to store the processed data. Default: ~/.dgl/
    force_reload : bool, optional
        Whether to always generate the data from scratch rather than load a cached version.
        Default: False
    verbose : bool, optional
        Whether to print progress information. Default: True
    transform : callable, optional
        A transform that takes in a :class:`~dgl.DGLGraph` object and returns
        a transformed version. The :class:`~dgl.DGLGraph` object will be
        transformed before every access. Default: None

    Attributes
    ----------
    num_classes : int
        Number of node classes

    Examples
    --------

    >>> from dgl.data import BAShapes
    >>> dataset = BAShapes()
    >>> dataset.num_classes
    4
    >>> g = dataset[0]
    >>> label = g.ndata['label']
    >>> feat = g.ndata['feat']
    """
    def __init__(self,
                 num_base_nodes=300,
                 num_base_edges_per_node=5,
                 num_motifs=80,
                 perturb_ratio=0.01,
                 seed=None,
                 raw_dir=None,
                 force_reload=False,
                 verbose=True,
                 transform=None):
        self.num_base_nodes = num_base_nodes
        self.num_base_edges_per_node = num_base_edges_per_node
        self.num_motifs = num_motifs
        self.perturb_ratio = perturb_ratio
        self.seed = seed
        super(BAShapes, self).__init__(name='BA-SHAPES',
                                       url=None,
                                       raw_dir=raw_dir,
                                       force_reload=force_reload,
                                       verbose=verbose,
                                       transform=transform)

    def download(self):
        """Downloading does not apply as the dataset is generated from scratch."""
        pass

    def process(self):
        g = nx.barabasi_albert_graph(self.num_base_nodes, self.num_base_edges_per_node, self.seed)
        edges = list(g.edges())
        src, dst = map(list, zip(*edges))
        n = self.num_base_nodes

        # Nodes in the base BA graph belong to class 0
        node_labels = [0] * self.num_base_nodes
        # The motifs will be evenly attached to the nodes in the base graph.
        spacing = math.floor(self.num_base_nodes / self.num_motifs)

        for motif_id in range(self.num_motifs):
            # Construct a five-node house-structured network motif
            motif_edges = [
                (n, n + 1),
                (n + 1, n + 2),
                (n + 2, n + 3),
                (n + 3, n),
                (n + 4, n),
                (n + 4, n + 1)
            ]
            motif_src, motif_dst = map(list, zip(*motif_edges))
            src.extend(motif_src)
            dst.extend(motif_dst)

            # Nodes at the middle of a house belong to class 1
            # Nodes at the bottom of a house belong to class 2
            # Nodes at the top of a house belong to class 3
            node_labels.extend([1, 1, 2, 2, 3])

            # Attach the motif to the base BA graph
            src.append(n)
            dst.append(int(motif_id * spacing))
            n += 5

        g = graph((src, dst), num_nodes=n)

        # Perturb the graph by adding non-self-loop random edges
        num_real_edges = g.num_edges()
        max_ratio = (n * (n - 1) - num_real_edges) / num_real_edges
        assert self.perturb_ratio <= max_ratio, \
            'perturb_ratio cannot exceed {:.4f}'.format(max_ratio)
        num_random_edges = int(num_real_edges * self.perturb_ratio)

        np.random.seed(self.seed)
        for _ in range(num_random_edges):
            while True:
                u = np.random.randint(0, n)
                v = np.random.randint(0, n)
                if (not g.has_edges_between(u, v)) and (u != v):
                    break
            g.add_edges(u, v)

        g.ndata['label'] = F.tensor(node_labels, F.int64)
        g.ndata['feat'] = F.ones((n, 1), F.float32, F.cpu())
        self._graph = reorder_graph(
            g, node_permute_algo='rcmk', edge_permute_algo='dst', store_ids=False)

    @property
    def graph_path(self):
        return os.path.join(self.save_path, '{}_dgl_graph.bin'.format(self.name))

    def save(self):
        save_graphs(str(self.graph_path), self._graph)

    def has_cache(self):
        return os.path.exists(self.graph_path)

    def load(self):
        graphs, _ = load_graphs(str(self.graph_path))
        self._graph = graphs[0]

    def __getitem__(self, idx):
        assert idx == 0, "This dataset has only one graph."
        if self._transform is None:
            return self._graph
        else:
            return self._transform(self._graph)

    def __len__(self):
        return 1

    @property
    def num_classes(self):
        return 4

class BACommunity(DGLBuiltinDataset):
    r"""BA-COMMUNITY dataset from `GNNExplainer: Generating Explanations for Graph Neural Networks
    <https://arxiv.org/abs/1903.03894>`__

    This is a synthetic dataset for node classification. It is generated by performing the
    following steps in order.

    - Construct a base Barabási–Albert (BA) graph.
    - Construct a set of five-node house-structured network motifs.
    - Attach the motifs to randomly selected nodes of the base graph.
    - Perturb the graph by adding random edges.
    - Nodes are assigned to 4 classes. Nodes of label 0 belong to the base BA graph. Nodes of
      label 1, 2, 3 are separately at the middle, bottom, or top of houses.
    - Generate normally distributed features.
    - Repeat the above steps to generate another graph. Its nodes are assigned to class
      4, 5, 6, 7. Its node features are generated with a distinct normal distribution.
    - Join the two graphs by randomly adding edges between them.

    Parameters
    ----------
    num_base_nodes : int, optional
        Number of nodes in each base BA graph. Default: 300
    num_base_edges_per_node : int, optional
        Number of edges to attach from a new node to existing nodes in constructing a base BA
        graph. Default: 4
    num_motifs : int, optional
        Number of house-structured network motifs to use in constructing each graph. Default: 80
    perturb_ratio : float, optional
        Number of random edges to add to a graph in perturbation divided by the number of original
        edges in it. Default: 0.01
    num_inter_edges : int, optional
        Number of random edges to add between the two graphs. Default: 350
    seed : integer, random_state, or None
        Indicator of random number generation state. Default: None
    raw_dir : str, optional
        Raw file directory to store the processed data. Default: ~/.dgl/
    force_reload : bool, optional
        Whether to always generate the data from scratch rather than load a cached version.
        Default: False
    verbose : bool, optional
        Whether to print progress information. Default: True
    transform : callable, optional
        A transform that takes in a :class:`~dgl.DGLGraph` object and returns
        a transformed version. The :class:`~dgl.DGLGraph` object will be
        transformed before every access. Default: None

    Attributes
    ----------
    num_classes : int
        Number of node classes

    Examples
    --------
    """
    def __init__(self,
                 num_base_nodes=300,
                 num_base_edges_per_node=4,
                 num_motifs=80,
                 perturb_ratio=0.01,
                 num_inter_edges=350,
                 seed=None,
                 raw_dir=None,
                 force_reload=False,
                 verbose=True,
                 transform=None):
        self.num_base_nodes = num_base_nodes
        self.num_base_edges_per_node = num_base_edges_per_node
        self.num_motifs = num_motifs
        self.perturb_ratio = perturb_ratio
        self.num_inter_edges = num_inter_edges
        self.seed = seed
        super(BACommunity, self).__init__(name='BA-COMMUNITY',
                                          url=None,
                                          raw_dir=raw_dir,
                                          force_reload=force_reload,
                                          verbose=verbose,
                                          transform=transform)

    def download(self):
        """Downloading does not apply as the dataset is generated from scratch."""
        pass

    def process(self):
        random.seed(self.seed)
        np.random.seed(self.seed)

        # Construct two BA-SHAPES graphs
        g1 = BAShapes(self.num_base_nodes,
                      self.num_base_edges_per_node,
                      self.num_motifs,
                      self.perturb_ratio,
                      force_reload=True)[0]
        g2 = BAShapes(self.num_base_nodes,
                      self.num_base_edges_per_node,
                      self.num_motifs,
                      self.perturb_ratio,
                      force_reload=True)[0]

        # Join them and randomly add edges between them
        g = batch([g1, g2])
        num_nodes = g.num_nodes() // 2
        src = F.randint((self.num_inter_edges,), g.idtype, g.device, 0, num_nodes)
        dst = F.randint((self.num_inter_edges,), g.idtype, g.device, num_nodes, 2 * num_nodes)
        g.add_edges(src, dst)
        g.ndata['label'] = F.cat([g1.ndata['label'], g2.ndata['label'] + 4], dim=0)

        # feature generation
        random_mu = [0.0] * 8
        random_sigma = [1.0] * 8

        mu_1, sigma_1 = np.array([-1.0] * 2 + random_mu), np.array([0.5] * 2 + random_sigma)
        feat1 = np.random.multivariate_normal(mu_1, np.diag(sigma_1), num_nodes)

        mu_2, sigma_2 = np.array([1.0] * 2 + random_mu), np.array([0.5] * 2 + random_sigma)
        feat2 = np.random.multivariate_normal(mu_2, np.diag(sigma_2), num_nodes)

        feat = np.concatenate([feat1, feat2])
        g.ndata['feat'] = F.zerocopy_from_numpy(feat)
        self._graph = reorder_graph(
            g, node_permute_algo='rcmk', edge_permute_algo='dst', store_ids=False)

    @property
    def graph_path(self):
        return os.path.join(self.save_path, '{}_dgl_graph.bin'.format(self.name))

    def save(self):
        save_graphs(str(self.graph_path), self._graph)

    def has_cache(self):
        return os.path.exists(self.graph_path)

    def load(self):
        graphs, _ = load_graphs(str(self.graph_path))
        self._graph = graphs[0]

    def __getitem__(self, idx):
        assert idx == 0, "This dataset has only one graph."
        if self._transform is None:
            return self._graph
        else:
            return self._transform(self._graph)

    def __len__(self):
        return 1

    @property
    def num_classes(self):
        return 8
