"""Module for graph traversal methods."""
from __future__ import absolute_import

from ._ffi.function import _init_api
from . import backend as F

def bfs_nodes_generator(graph, source, reversed=False):
    """Node frontiers generator using breadth-first search.

    Parameters
    ----------
    graph : DGLGraph
        The graph object.
    source : list, tensor of nodes
        Source nodes.
    reversed : bool
        Whether to following incoming or outgoing edges.

    Returns
    -------
    list of node frontiers
        Each node frontier is a list, tensor of nodes.
    """
    source = utils.toindex(source).todgltensor()
    ret = _CAPI_DGLBFSNodes(graph._graph, source, reversed)
    all_nodes = utils.toindex(ret(0)).tousertensor()
    section = utils.toindex(ret(1)).tousertensor()
    return F.split()

def dfs_labeled_edges(self, src, out, reverse_edge, nontree_edge):
    """ Produce edges in a depth-first-search (DFS) labeled by type.

    Parameters
    ----------
    src : int, list or tensor
        Source nodes.
    out : bool
        Whether to following incoming or outgoing edges.
    reverse_edge : bool
        Whether to yield reverse edges.
    nontree_edge : bool
        Whether to yield nontree edges.

    Returns
    -------
    list of tuple of tensor
        A tuple in returned list consists of three tensors:
        * src: Source id's.
        * dst: Destination id's.
        * type: A tensor that takes value in `GraphIndex.FORWARD`, `GraphIndex.REVERSE` and `GraphIndex.NONTREE`.
        Propagation from source nodes to destination nodes in the same tuple can be parallelized.
    """
    src = utils.toindex(src).todgltensor()
    ret = _CAPI_DGLGraphDFSLabeledEdges(self._handle, src, out, reverse_edge, nontree_edge)
    src = utils.toindex(ret(0)).tousertensor()
    dst = utils.toindex(ret(1)).tousertensor()
    type = utils.toindex(ret(2)).tousertensor()
    size = F.asnumpy(utils.toindex(ret(3)).tousertensor()).tolist()
    return list(zip(F.unpack(src, size), F.unpack(dst, size), F.unpack(type, size)))

def topological_traversal(self, out):
    """ Topological Traversal.

    Parameters
    ----------
    out : bool
        Whether to following incoming or outgoing edges.

    Returns
    -------
    tuple of tensor
        Layers generated by topological traversal.
        This layers can serve as frontiers in propagation.
    """
    pair = _CAPI_DGLGraphTopologicalTraversal(self._handle, out)
    v = utils.toindex(pair(0)).tousertensor()
    s = utils.toindex(pair(1)).tousertensor()
    return F.unpack(v, s.tolist())

_init_api("dgl.traversal")
